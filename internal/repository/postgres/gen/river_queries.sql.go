// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_queries.sql

package gen

import (
	"context"
	"time"
)

const countRiverReadings = `-- name: CountRiverReadings :one
SELECT COUNT(*) FROM riverlevels
`

// Count total river level readings
func (q *Queries) CountRiverReadings(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countRiverReadingsStmt, countRiverReadings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRiverReadingsWithStartDate = `-- name: CountRiverReadingsWithStartDate :one
SELECT COUNT(*) FROM riverlevels
WHERE timestamp >= $1
`

// Count river level readings from a start date
func (q *Queries) CountRiverReadingsWithStartDate(ctx context.Context, timestamp time.Time) (int64, error) {
	row := q.queryRow(ctx, q.countRiverReadingsWithStartDateStmt, countRiverReadingsWithStartDate, timestamp)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRiverReadings = `-- name: GetRiverReadings :many
SELECT timestamp, level
FROM riverlevels
ORDER BY timestamp ASC
LIMIT $1 OFFSET $2
`

type GetRiverReadingsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type GetRiverReadingsRow struct {
	Timestamp time.Time `db:"timestamp"`
	Level     float64   `db:"level"`
}

// Get river level readings sorted in chronological order with pagination
func (q *Queries) GetRiverReadings(ctx context.Context, arg GetRiverReadingsParams) ([]GetRiverReadingsRow, error) {
	rows, err := q.query(ctx, q.getRiverReadingsStmt, getRiverReadings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRiverReadingsRow{}
	for rows.Next() {
		var i GetRiverReadingsRow
		if err := rows.Scan(&i.Timestamp, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRiverReadingsWithStartDate = `-- name: GetRiverReadingsWithStartDate :many
SELECT timestamp, level
FROM riverlevels
WHERE timestamp >= $1
ORDER BY timestamp ASC
LIMIT $2 OFFSET $3
`

type GetRiverReadingsWithStartDateParams struct {
	Timestamp time.Time `db:"timestamp"`
	Limit     int32     `db:"limit"`
	Offset    int32     `db:"offset"`
}

type GetRiverReadingsWithStartDateRow struct {
	Timestamp time.Time `db:"timestamp"`
	Level     float64   `db:"level"`
}

// Get river level readings from a start date sorted in chronological order with pagination
func (q *Queries) GetRiverReadingsWithStartDate(ctx context.Context, arg GetRiverReadingsWithStartDateParams) ([]GetRiverReadingsWithStartDateRow, error) {
	rows, err := q.query(ctx, q.getRiverReadingsWithStartDateStmt, getRiverReadingsWithStartDate, arg.Timestamp, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRiverReadingsWithStartDateRow{}
	for rows.Next() {
		var i GetRiverReadingsWithStartDateRow
		if err := rows.Scan(&i.Timestamp, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
