// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rainfall_queries.sql

package gen

import (
	"context"
	"time"
)

const countRainfallReadingsByStation = `-- name: CountRainfallReadingsByStation :one
SELECT COUNT(*) FROM rainfalls
WHERE stationid = $1
`

// Count rainfall readings for a station
func (q *Queries) CountRainfallReadingsByStation(ctx context.Context, stationid string) (int64, error) {
	row := q.queryRow(ctx, q.countRainfallReadingsByStationStmt, countRainfallReadingsByStation, stationid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRainfallReadingsByStationWithStartDate = `-- name: CountRainfallReadingsByStationWithStartDate :one
SELECT COUNT(*) FROM rainfalls
WHERE stationid = $1 AND timestamp >= $2
`

type CountRainfallReadingsByStationWithStartDateParams struct {
	Stationid string    `db:"stationid"`
	Timestamp time.Time `db:"timestamp"`
}

// Count rainfall readings for a station from a start date
func (q *Queries) CountRainfallReadingsByStationWithStartDate(ctx context.Context, arg CountRainfallReadingsByStationWithStartDateParams) (int64, error) {
	row := q.queryRow(ctx, q.countRainfallReadingsByStationWithStartDateStmt, countRainfallReadingsByStationWithStartDate, arg.Stationid, arg.Timestamp)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRainfallReadingsByStation = `-- name: GetRainfallReadingsByStation :many
SELECT timestamp, level, stationid
FROM rainfalls
WHERE stationid = $1
ORDER BY timestamp ASC
LIMIT $2 OFFSET $3
`

type GetRainfallReadingsByStationParams struct {
	Stationid string `db:"stationid"`
	Limit     int32  `db:"limit"`
	Offset    int32  `db:"offset"`
}

type GetRainfallReadingsByStationRow struct {
	Timestamp time.Time `db:"timestamp"`
	Level     float64   `db:"level"`
	Stationid string    `db:"stationid"`
}

// Get rainfall readings for a station sorted in chronological order with pagination
func (q *Queries) GetRainfallReadingsByStation(ctx context.Context, arg GetRainfallReadingsByStationParams) ([]GetRainfallReadingsByStationRow, error) {
	rows, err := q.query(ctx, q.getRainfallReadingsByStationStmt, getRainfallReadingsByStation, arg.Stationid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRainfallReadingsByStationRow{}
	for rows.Next() {
		var i GetRainfallReadingsByStationRow
		if err := rows.Scan(&i.Timestamp, &i.Level, &i.Stationid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRainfallReadingsByStationWithStartDate = `-- name: GetRainfallReadingsByStationWithStartDate :many
SELECT timestamp, level, stationid
FROM rainfalls
WHERE stationid = $1 AND timestamp >= $2
ORDER BY timestamp ASC
LIMIT $3 OFFSET $4
`

type GetRainfallReadingsByStationWithStartDateParams struct {
	Stationid string    `db:"stationid"`
	Timestamp time.Time `db:"timestamp"`
	Limit     int32     `db:"limit"`
	Offset    int32     `db:"offset"`
}

type GetRainfallReadingsByStationWithStartDateRow struct {
	Timestamp time.Time `db:"timestamp"`
	Level     float64   `db:"level"`
	Stationid string    `db:"stationid"`
}

// Get rainfall readings for a station from a start date sorted in chronological order with pagination
func (q *Queries) GetRainfallReadingsByStationWithStartDate(ctx context.Context, arg GetRainfallReadingsByStationWithStartDateParams) ([]GetRainfallReadingsByStationWithStartDateRow, error) {
	rows, err := q.query(ctx, q.getRainfallReadingsByStationWithStartDateStmt, getRainfallReadingsByStationWithStartDate,
		arg.Stationid,
		arg.Timestamp,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRainfallReadingsByStationWithStartDateRow{}
	for rows.Next() {
		var i GetRainfallReadingsByStationWithStartDateRow
		if err := rows.Scan(&i.Timestamp, &i.Level, &i.Stationid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationByID = `-- name: GetStationByID :one
SELECT id, name FROM stationnames
WHERE id = $1
`

// Get station information by ID for validation
func (q *Queries) GetStationByID(ctx context.Context, id string) (Stationname, error) {
	row := q.queryRow(ctx, q.getStationByIDStmt, getStationByID, id)
	var i Stationname
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getStationByName = `-- name: GetStationByName :one
SELECT id, name FROM stationnames
WHERE name = $1
`

// Get station information by name for API lookups
func (q *Queries) GetStationByName(ctx context.Context, name string) (Stationname, error) {
	row := q.queryRow(ctx, q.getStationByNameStmt, getStationByName, name)
	var i Stationname
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
